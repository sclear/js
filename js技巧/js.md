# JS内存模型

    在以前一直理解错误STACK内,变量直接指向值,原来还是有一层地址

    当栈中存在 a = '1' b = a, ab共享地址
    当栈中存在 a = '1' b = '1' a===b ab也能共享地址
    HEAP: 内部数据结构为多引用关系 单个对象也将其拆分并拥有非相同地址
    STACK && HEAP 存在相等基础类型值, 也将共享相同地址

> STACK  


| Address | VALUE | 这是临时变量(我的定义) |
| ------- | ----- | -------------------- |
| 0012CCG |  23   |                      |

STACK中也是地址与值作绑定  
当声明变量`myNumber`

| Address | VALUE | 这是临时变量(我的定义) |
| ------- | ----- | -------------------- |
| 0012CCG |  23   |      myNumber        |

### 我的错误理解
---

当再次定义`newNumber`并且等于23, 我的想法是会重新分配新地址
| Address | VALUE | 这是临时变量(我的定义) |
| ------- | ----- | -------------------- |
| 0012CCG |  23   |      myNumber        |
| 0013AAT |  23   |      newNumber       |

### 正确的模型
---

| Address | VALUE | 这是临时变量(我的定义) |
| ------- | ----- | -------------------- |
| 0012CCG |  23   |  myNumber,newNumber  |

当`newNumber = newNumber + 1`是不是`myNumber也会加1呢`  
当`newNumber + 1`后`newNumber`会重新分配地址


# STACK AND HEAP
---

当定义引用对象`myArray`

>STACK

| Address | VALUE | 这是临时变量(我的定义) |
| ------- | ----- | -------------------- |
| 0012GHH |9852AEK|  myArray             |

>HEAP

| Address | VALUE |
| ------- | ----- |
| 9852AEK |  [0,1,2]   |

    原来myArray引用了STACK中的地址,的值又引用了HEAP中的值


*已经引出了一个问题? Let Const用法???*  
    
我们都明白***const***声明必须初始化 并且过程中不能够被`改变`  
而***let***可以不用初始化值 并且过程中可以被`改变`  
我们在使用js过程中也发现了const其实使用引用类型是可以被改变其值,而不能改变其引用  
加上康康文章 发现let起手的我好像错了  
    在开发过程中当值确定不改变,这个改变所指的是**引用**而不是值,我是不是该多用`const`了,而let应该用于需要重新分配变量的场景  
    或许这能够有效的限制一些bug,便于我们更好的管理内存,这也算是一种规范'哪些能改变,哪些不能改变'
